{"version":3,"file":"simple-md-parser.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;UCVA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,CAAQ,uBAAuB,+BAA+B;;AAE9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA,kBAAkB,UAAU;AAC5B;AACA,wBAAwB,sBAAsB,IAAI,mCAAmC,MAAM;AAC3F;AACA,yBAAyB,qBAAqB,SAAS,mCAAmC,0BAA0B,GAAG;AACvH;AACA,qBAAqB,sCAAsC,SAAS;AACpE;AACA,0BAA0B,sCAAsC,oCAAoC,QAAQ;AAC5G;AACA,mBAAmB,6BAA6B,KAAK,iBAAiB;AACtE;AACA,mBAAmB,6BAA6B,KAAK,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gEAAgE,MAAM,QAAQ,IAAI;AAClF,6EAA6E,MAAM,QAAQ,IAAI;AAC/F,6EAA6E,MAAM,QAAQ,IAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;;AAE1B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,8DAA8D;AAC9E;AACA;AACA;AACA;AACA,eAAe,yEAAyE;AACxF;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,8DAA8D;AAC9E;AACA;AACA;AACA;AACA,eAAe,yEAAyE;AACxF;AACA;;AAEA;;AAEA,4BAA4B,IAAI;AAChC;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAmE,wBAAwB;AAC9H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA,iCAAiC,kCAAkC;AACnE;AACA;;AAEA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;;AAEA;AACA,C","sources":["webpack://simpleMDParser/webpack/universalModuleDefinition","webpack://simpleMDParser/webpack/bootstrap","webpack://simpleMDParser/webpack/runtime/define property getters","webpack://simpleMDParser/webpack/runtime/hasOwnProperty shorthand","webpack://simpleMDParser/webpack/runtime/make namespace object","webpack://simpleMDParser/./src/simple-md-parser.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"simpleMDParser\"] = factory();\n\telse\n\t\troot[\"simpleMDParser\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Convert a string containing Markdown links, images, codeblocks, inline code, bold and italic text to an HTML string.\n *   1. Remove duplicate linebreaks and spaces (including <br>)\n *   2. Convert linebreaks to <br>\n *   3. Convert URLs that are not part of a markdown tag to markdown tags\n *   4. Convert ``` MD code blocks to <pre><code> blocks\n *   5. Convert ` inline code to <code> tags\n *   6. Convert ** bold tags to <b> tags\n *   7. Convert * italics tags to <i> tags\n *   8. Convert ![]() image tags to <img> tags\n *   9. Convert []() links (including the ones from step 3) to <a> tags\n * @param {String} str - The Markdown string to convert to HTML\n * @param {Function} url_callback (optional) - A function that is called for each URL\n *\t The callback function is provided two params - A URL and a the type of tag it was called from  (\"image\" or \"link\")\n *\t If the function returns a promise, it will be awaited and the result used\n *\t If the function returns a string that is a complete, valid URL, the string will be used.\n *\t If the function returns anything else, the tag will not be processed at all.\n * @return {String} - Apromise that resolves with the string containing the HTML converted Markdown \n */\n export async function parse({ str, url_callback, render_tag }) {\n\n\tif (typeof str !== \"string\") return \"\";\n\n\tconst validate_url = async (url, type) => {\n\t\ttry {\n\t\t\tif ('function' === typeof url_callback) {\n\t\t\t\turl = await Promise.resolve(url_callback(url, type));\n\t\t\t}\n\t\t\tnew URL(url);\n\t\t\treturn url;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tif (typeof render_tag !== 'function') {\n\t\trender_tag = (tagname, attrs, innerText) => {\n\t\t\tswitch (tagname) {\n\t\t\t\tcase \"b\":\n\t\t\t\t\treturn `<b>${innerText}</b>`;\n\t\t\t\tcase \"i\":\n\t\t\t\t\treturn `<i>${innerText}</i>`;\n\t\t\t\tcase \"a\":\n\t\t\t\t\treturn `<a href=\"${encodeURI(attrs.href)}\">${innerText.replace(/<\\/a>/gmi, '&lt;/a>')}</a>`;\n\t\t\t\tcase \"img\":\n\t\t\t\t\treturn `<img src=\"${encodeURI(attrs.src)}\" alt=\"${attrs.alt.replace(/\\\\/gmi, '&#8726;').replace(/\"/gmi, '&quot;')}\" />`;\n\t\t\t\tcase \"code\":\n\t\t\t\t\treturn `<code>${innerText.replace(/<\\/code>/gmi, '&lt;/code>')}</code>`;\n\t\t\t\tcase \"pre\":\n\t\t\t\t\treturn `<pre><code>${innerText.replace(/<\\/code>/gmi, '&lt;/code>').replace(/<\\/pre>/gmi, '&lt;/pre>')}</code></pre>`;\n\t\t\t\tcase \"ul\":\n\t\t\t\t\treturn `<ul>${innerText.map(text => `<li>${text}</li>`).join('')}</ul>`;\n\t\t\t\tcase \"ol\":\n\t\t\t\t\treturn `<ol>${innerText.map(text => `<li>${text}</li>`).join('')}</ol>`;\n\t\t\t\tcase \"br\":\n\t\t\t\t\treturn `<br />`;\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"\";\n\t\t\t}\n\t\t};\n\t}\n\n\tvar url_regex = /(https?:\\/\\/)?((www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}|localhost)\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/gmi,\n\t\timg_regex = /!\\[([^\\]]*)\\]\\(((https?:\\/\\/)?((www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}|localhost)\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*))\\)/gmi,\n\t\tlink_regex = /\\[([^\\]]*)\\]\\(((https?:\\/\\/)?((www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}|localhost)\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*))\\)/gmi,\n\t\topening_pos = false,\n\t\tclosing_pos = false,\n\t\tlast_index = 0,\n\t\tlink_matches,\n\t\timg_matches,\n\t\turl_matches;\n\n\t// Convert <br> to \\n\n\t// Remove extra spaces\n\t// Ensure no more than two consecutive line breaks\n\tstr = str.replace(/<br[^>]*>/gmi, \"\\n\");\n\tstr = str.replace(/ +/gmi, ' ');\n\tstr = str.replace(/\\n{2,}/gmi, \"\\n\\n\");\n\n\t// Parse lists\n\tlet lines = str.split(/\\n/);\n\tlet curr_list = [];\n\tlet lists = [];\n\n\tlet is_prev_line_list_item = false;\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tlet item = lines[i].match(/^\\s*-\\s?([^\\n]*)$/);\n\t\tif (lines[i].match(/^\\s*--/)) item = null;\n\t\tif (item !== null) {\n\t\t\tcurr_list.push(item[1]);\n\t\t} else if (curr_list.length) {\n\t\t\tlists.push({ type: 'ul', line_pos: i - curr_list.length, items: curr_list });\n\t\t\tcurr_list = [];\n\t\t}\n\t}\n\tif (curr_list.length) {\n\t\tlists.push({ type: 'ul', line_pos: lines.length - curr_list.length, items: curr_list });\n\t\tcurr_list = [];\n\t}\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tlet item = lines[i].match(/^\\s*\\d+[\\.\\)]\\s?([^\\n]*)$/);\n\t\tif (item !== null) {\n\t\t\tcurr_list.push(item[1]);\n\t\t} else if (curr_list.length) {\n\t\t\tlists.push({ type: 'ol', line_pos: i - curr_list.length, items: curr_list });\n\t\t\tcurr_list = [];\n\t\t}\n\t}\n\tif (curr_list.length) {\n\t\tlists.push({ type: 'ol', line_pos: lines.length - curr_list.length, items: curr_list });\n\t\tcurr_list = [];\n\t}\n\n\tlists.sort((a, b) => a.line_pos > b.line_pos ? 1 : -1);\n\n\tfor (let i = lists.length; i--;) {\n\t\tlines.splice(lists[i].line_pos, lists[i].items.length);\n\t\tlines[lists[i].line_pos] = render_tag(lists[i].type, {}, lists[i].items) + (lines[lists[i].line_pos] || '');\n\t\tif (lines[lists[i].line_pos - 1]) {\n\t\t\tlines[lists[i].line_pos - 1] += lines[lists[i].line_pos];\n\t\t\tlines.splice(lists[i].line_pos, 1);\n\t\t}\n\t}\n\n\t// Convert line breaks (back) to <br>\n\tstr = lines.join(render_tag('br', {}, null));\n\n\t// Find all URLs that are not part of an image or link tag and convert them to a link tag\n\turl_matches = [...str.matchAll(url_regex)].reverse();\n\turl_matches_loop: for (let n = 0; n < url_matches.length; n++) {\n\t\tvar url = await validate_url(url_matches[n][0], 'link');\n\t\tif (false === url) continue;\n\n\t\tlink_matches = [...str.matchAll(link_regex)].reverse();\n\t\tfor (let i = 0; i < link_matches.length; i++) {\n\t\t\tif (url_matches[n].index > link_matches[i].index && url_matches[n].index < link_matches[i].index + link_matches[i][0].length) {\n\t\t\t\tcontinue url_matches_loop;\n\t\t\t}\n\t\t}\n\n\t\timg_matches = [...str.matchAll(img_regex)].reverse();\n\t\tfor (let i = 0; i < img_matches.length; i++) {\n\t\t\tif (url_matches[n].index > img_matches[i].index && url_matches[n].index < img_matches[i].index + img_matches[i][0].length) {\n\t\t\t\tcontinue url_matches_loop;\n\t\t\t}\n\t\t}\n\n\t\tstr = str.substring(0, url_matches[n].index + url_matches[n][0].length) + ')' + str.substring(url_matches[n].index + url_matches[n][0].length);\n\t\tstr = str.substring(0, url_matches[n].index) + '[' + url_matches[n][0] + '](' + url + str.substring(url_matches[n].index + url_matches[n][0].length);\n\t}\n\n\t// block code\n\twhile (last_index > -1) {\n\t\tlast_index = str.indexOf(\"```\", last_index);\n\t\tif (last_index > -1) {\n\t\t\tif (opening_pos === false) opening_pos = last_index;\n\t\t\telse closing_pos = last_index;\n\t\t\tlast_index += 3;\n\t\t}\n\t\tif (opening_pos !== false && closing_pos !== false) {\n\t\t\tlet br = render_tag('br', {}, null)\n\t\t\tlet block_code = str.substring(opening_pos + 3, closing_pos);\n\n\t\t\tif(block_code.startsWith(br)){\n\t\t\t\tblock_code = block_code.substring(br.length)\n\t\t\t}\n\t\t\t\n\t\t\tif(block_code.endsWith(br)){\n\t\t\t\tblock_code = block_code.substring(0, block_code.length-br.length)\n\t\t\t}\n\n\t\t\tblock_code = block_code.replaceAll(br, \"\\n\");\n\t\t\tblock_code = block_code.replaceAll('<', '&lt;');\n\t\t\tblock_code = block_code.replaceAll('>', '&gt;');\n\t\t\tlet html = render_tag('pre', {}, block_code);\n\t\t\thtml = html.replaceAll(\"\\n\", br);\n\n\t\t\tlet before_html = str.substring(0, opening_pos);\n\t\t\tlet after_html = str.substring(closing_pos + 3).replace(/^\\s*/, '');\n\n\t\t\t// remove up to 2 line breaks following the code block, since <pre> is a block level element\n\t\t\tif(after_html.startsWith(br)){\n\t\t\t\tafter_html = after_html.substring(br.length);\n\t\t\t\tif(after_html.startsWith(br)){\n\t\t\t\t\tafter_html = after_html.substring(br.length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstr = before_html + html + after_html;\n\n\t\t\tlast_index = opening_pos + html.length;\n\t\t\topening_pos = false;\n\t\t\tclosing_pos = false;\n\t\t}\n\t}\n\n\topening_pos = false;\n\tclosing_pos = false;\n\tlast_index = 0;\n\n\t// inline code\n\twhile (last_index > -1) {\n\t\tlast_index = str.indexOf(\"`\", last_index);\n\t\tif (last_index > -1) {\n\t\t\tif (opening_pos === false) opening_pos = last_index;\n\t\t\telse closing_pos = last_index;\n\t\t\tlast_index++;\n\t\t}\n\t\tif (opening_pos !== false && closing_pos !== false) {\n\t\t\tlet html = render_tag('code', {}, str.substring(opening_pos + 1, closing_pos).replaceAll('<', '&lt;').replaceAll('>', '&gt;'));\n\t\t\tstr = str.substring(0, opening_pos) + html + str.substring(closing_pos + 1);\n\t\t\tlast_index = opening_pos + html.length;\n\t\t\topening_pos = false;\n\t\t\tclosing_pos = false;\n\t\t}\n\t}\n\n\topening_pos = false;\n\tclosing_pos = false;\n\tlast_index = 0;\n\n\t// replace bold tags\n\twhile (last_index > -1) {\n\t\tlast_index = str.indexOf(\"**\", last_index);\n\t\tif (last_index > -1) {\n\t\t\tif (opening_pos === false) opening_pos = last_index;\n\t\t\telse closing_pos = last_index;\n\t\t\tlast_index += 2;\n\t\t}\n\t\tif (opening_pos !== false && closing_pos !== false) {\n\t\t\tlet html = render_tag('b', {}, str.substring(opening_pos + 2, closing_pos));\n\t\t\tstr = str.substring(0, opening_pos) + html + str.substring(closing_pos + 2);\n\t\t\tlast_index = opening_pos + html.length;\n\t\t\topening_pos = false;\n\t\t\tclosing_pos = false;\n\t\t}\n\t}\n\n\topening_pos = false;\n\tclosing_pos = false;\n\tlast_index = 0;\n\n\t// replace italic tags\n\twhile (last_index > -1) {\n\t\tlast_index = str.indexOf(\"*\", last_index);\n\t\tif (last_index > -1) {\n\t\t\tif (opening_pos === false) opening_pos = last_index;\n\t\t\telse closing_pos = last_index;\n\t\t\tlast_index++;\n\t\t}\n\t\tif (opening_pos !== false && closing_pos !== false) {\n\t\t\tlet html = render_tag('i', {}, str.substring(opening_pos + 1, closing_pos));\n\t\t\tstr = str.substring(0, opening_pos) + html + str.substring(closing_pos + 1);\n\t\t\tlast_index = opening_pos + html.length;\n\t\t\topening_pos = false;\n\t\t\tclosing_pos = false;\n\t\t}\n\t}\n\n\t// Convert img tags to <img>\n\timg_matches = [...str.matchAll(img_regex)].reverse();\n\tfor (let n = 0; n < img_matches.length; n++) {\n\t\tvar url = await validate_url(img_matches[n][2], 'image');\n\t\tif (false === url) continue;\n\t\tlet html = render_tag('img', { src: url, alt: img_matches[n][1] }, null);\n\t\tstr = str.substring(0, img_matches[n].index) + html + str.substring(img_matches[n].index + img_matches[n][0].length);\n\t}\n\n\t// Convert links to <a> tags\n\tlink_matches = [...str.matchAll(link_regex)].reverse();\n\tfor (let n = 0; n < link_matches.length; n++) {\n\t\tvar url = await validate_url(link_matches[n][2], 'link');\n\t\tif (false === url) continue;\n\t\tlet html = render_tag('a', { href: url }, link_matches[n][1]);\n\t\tstr = str.substring(0, link_matches[n].index) + html + str.substring(link_matches[n].index + link_matches[n][0].length);\n\t}\n\n\treturn str;\n}"],"names":[],"sourceRoot":""}